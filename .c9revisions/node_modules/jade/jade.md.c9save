{"ts":1363512880697,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\n# Jade\n\n  The jade template engine for node.js\n\n## Synopsis\n\n    jade [-h|--help] [-v|--version] [-o|--obj STR]\n         [-O|--out DIR] [-p|--path PATH] [-P|--pretty]\n         [-c|--client] [-D|--no-debug]\n\n## Examples\n\n  translate jade the templates dir\n\n    $ jade templates\n\n  create {foo,bar}.html\n\n    $ jade {foo,bar}.jade\n\n  jade over stdio\n\n    $ jade < my.jade > my.html\n\n  jade over s\n\n    $ echo \"h1 Jade!\" | jade\n\n  foo, bar dirs rendering to /tmp\n\n    $ jade foo bar --out /tmp\n\n  compile client-side templates without debugging\n  instrumentation, making the output javascript\n  very light-weight. This requires runtime.js\n  in your projects.\n\n     $ jade --client --no-debug < my.jade\n\n## Tags\n\n  Tags are simply nested via whitespace, closing\n  tags defined for you. These indents are called \"blocks\".\n  \n    ul\n      li\n        a Foo\n      li\n        a Bar\n\n  You may have several tags in one \"block\":\n  \n    ul\n      li\n        a Foo\n        a Bar\n        a Baz\n\n## Self-closing Tags\n\n  Some tags are flagged as self-closing by default, such\n  as `meta`, `link`, and so on. To explicitly self-close\n  a tag simply append the `/` character:\n\n     foo/\n     foo(bar='baz')/\n\n  Would yield:\n  \n     <foo/>\n     <foo bar=\"baz\"/>\n\n## Attributes\n\n  Tag attributes look similar to HTML, however\n  the values are regular JavaScript, here are\n  some examples:\n  \n    a(href='google.com') Google\n    a(class='button', href='google.com') Google\n\n  As mentioned the attribute values are just JavaScript,\n  this means ternary operations and other JavaScript expressions\n  work just fine:\n  \n    body(class=user.authenticated ? 'authenticated' : 'anonymous')\n    a(href=user.website || 'http://google.com')\n\n  Multiple lines work too:\n\n    input(type='checkbox',\n      name='agreement',\n      checked)\n\n  Multiple lines without the comma work fine:\n\n    input(type='checkbox'\n      name='agreement'\n      checked)\n\n  Funky whitespace? fine:\n\n    input(\n      type='checkbox'\n      name='agreement'\n      checked)\n\n## Boolean attributes\n\n  Boolean attributes are mirrored by Jade, and accept\n  bools, aka _true_ or _false_. When no value is specified\n  _true_ is assumed. For example:\n  \n    input(type=\"checkbox\", checked)\n    // => \"<input type=\"checkbox\" checked=\"checked\" />\"\n\n  For example if the checkbox was for an agreement, perhaps `user.agreed`\n  was _true_ the following would also output 'checked=\"checked\"':\n  \n     input(type=\"checkbox\", checked=user.agreed)\n\n## Class attributes\n\n  The _class_ attribute accepts an array of classes,\n  this can be handy when generated from a javascript\n  function etc:\n  \n    classes = ['foo', 'bar', 'baz']\n    a(class=classes)\n    // => \"<a class=\"foo bar baz\"></a>\"\n\n## Class literal\n\n  Classes may be defined using a \".CLASSNAME\" syntax:\n  \n     .button\n     // => \"<div class=\"button\"></div>\"\n  \n  Or chained:\n  \n     .large.button\n     // => \"<div class=\"large button\"></div>\"\n\n  The previous defaulted to divs, however you\n  may also specify the tag type:\n  \n      h1.title My Title\n      // => \"<h1 class=\"title\">My Title</h1>\"\n\n## Id literal\n\n  Much like the class literal there's an id literal:\n  \n    #user-1\n    // => \"<div id=\"user-1\"></div>\"\n\n  Again we may specify the tag as well:\n  \n    ul#menu\n      li: a(href='/home') Home\n      li: a(href='/store') Store\n      li: a(href='/contact') Contact\n\n  Finally all of these may be used in any combination,\n  the following are all valid tags:\n  \n    a.button#contact(style: 'color: red') Contact\n    a.button(style: 'color: red')#contact Contact\n    a(style: 'color: red').button#contact Contact\n\n## Block expansion\n\n  Jade supports the concept of \"block expansion\", in which\n  using a trailing \":\" after a tag will inject a block:\n  \n    ul\n      li: a Foo\n      li: a Bar\n      li: a Baz\n\n## Text\n\n   Arbitrary text may follow tags:\n   \n     p Welcome to my site\n  \n  yields:\n  \n     <p>Welcome to my site</p>\n\n## Pipe text\n\n  Another form of text is \"pipe\" text. Pipes act\n  as the text margin for large bodies of text.\n\n    p\n      | This is a large\n      | body of text for\n      | this tag.\n      | \n      | Nothing too\n      | exciting.\n\n  yields:\n  \n    <p>This is a large\n    body of text for\n    this tag.\n\n    Nothing too\n    exciting.\n    </p>\n\n  Using pipes we can also specify regular Jade tags\n  within the text:\n  \n    p\n      | Click to visit\n      a(href='http://google.com') Google\n      | if you want.\n\n## Text only tags\n\n  As an alternative to pipe text you may add\n  a trailing \".\" to indicate that the block\n  contains nothing but plain-text, no tags:\n\n    p.\n      This is a large\n      body of text for\n      this tag.\n\n      Nothing too\n      exciting.\n\n  Some tags are text-only by default, for example\n  _script_, _textarea_, and _style_ tags do not\n  contain nested HTML so Jade implies the trailing \".\":\n  \n    script\n      if (foo) {\n        bar();\n      }\n\n    style\n      body {\n        padding: 50px;\n        font: 14px Helvetica;\n      }\n\n## Template script tags\n\n  Sometimes it's useful to define HTML in script\n  tags using Jade, typically for client-side templates.\n  \n  To do this simply give the _script_ tag an arbitrary\n  _type_ attribute such as _text/x-template_:\n  \n    script(type='text/template')\n      h1 Look!\n      p Jade still works in here!\n\n## Interpolation\n\n  Both plain-text and piped-text support interpolation,\n  which comes in two forms, escapes and non-escaped. The\n  following will output the _user.name_ in the paragraph\n  but HTML within it will be escaped to prevent XSS attacks:\n  \n    p Welcome #{user.name}\n\n  The following syntax is identical however it will _not_ escape\n  HTML, and should only be used with strings that you trust:\n  \n    p Welcome !{user.name}\n  \n## Inline HTML\n\n  Sometimes constructing small inline snippets of HTML\n  in Jade can be annoying, luckily we can add plain\n  HTML as well:\n  \n    p Welcome <em>#{user.name}</em>\n\n## Code\n\n  To buffer output with Jade simply use _=_ at the beginning\n  of a line or after a tag. This method escapes any HTML\n  present in the string.\n  \n    p= user.description\n    \n  To buffer output unescaped use the _!=_ variant, but again\n  be careful of XSS.\n  \n    p!= user.description\n  \n  The final way to mess with JavaScript code in Jade is the unbuffered\n  _-_, which can be used for conditionals, defining variables etc:\n  \n    - var user = { description: 'foo bar baz' }\n    #user\n      - if (user.description) {\n        h2 Description\n        p.description= user.description\n      - }\n\n   When compiled blocks are wrapped in anonymous functions, so the\n   following is also valid, without braces:\n   \n     - var user = { description: 'foo bar baz' }\n     #user\n       - if (user.description)\n         h2 Description\n         p.description= user.description\n\n   If you really want you could even use `.forEach()` and others:\n   \n    - users.forEach(function(user){\n      .user\n        h2= user.name\n        p User #{user.name} is #{user.age} years old\n    - })\n\n   Taking this further Jade provides some syntax for conditionals,\n   iteration, switch statements etc. Let's look at those next!\n\n## Assignment\n\n  Jade's first-class assignment is simple, simply use the _=_\n  operator and Jade will _var_ it for you. The following are equivalent:\n  \n    - var user = { name: 'tobi' }\n    user = { name: 'tobi' }\n\n## Conditionals\n\n  Jade's first-class conditional syntax allows for optional\n  parenthesis, and you may now omit the leading _-_ otherwise\n  it's identical, still just regular javascript:\n  \n    user = { description: 'foo bar baz' }\n    #user\n      if user.description\n        h2 Description\n        p.description= user.description\n\n  Jade provides the negated version, _unless_ as well, the following\n  are equivalent:\n  \n    - if (!(user.isAnonymous))\n      p You're logged in as #{user.name}\n\n    unless user.isAnonymous\n      p You're logged in as #{user.name}\n\n## Iteration\n\n  JavaScript's _for_ loops don't look very declarative, so Jade\n  also provides its own _for_ loop construct, aliased as _each_:\n\n    for user in users\n      .user\n        h2= user.name\n        p user #{user.name} is #{user.age} year old\n\n   As mentioned _each_ is identical:\n   \n     each user in users\n       .user\n         h2= user.name\n\n   If necessary the index is available as well:\n   \n      for user, i in users\n        .user(class='user-#{i}')\n          h2= user.name\n\n   Remember, it's just JavaScript:\n   \n      ul#letters\n        for letter in ['a', 'b', 'c']\n          li= letter\n\n## Mixins\n\n  Mixins provide a way to define jade \"functions\" which \"mix in\"\n  their contents when called. This is useful for abstracting\n  out large fragments of Jade.\n\n  The simplest possible mixin which accepts no arguments might\n  look like this:\n  \n      mixin hello\n        p Hello\n\n   You use a mixin by placing `+` before the name:\n\n      +hello\n\n   For something a little more dynamic, mixins can take\n   arguments, the mixin itself is converted to a javascript\n   function internally:\n   \n       mixin hello(user)\n         p Hello #{user}\n\n       +hello('Tobi')\n  \n   Yields:\n\n       <p>Hello Tobi</p>\n\n  Mixins may optionally take blocks, when a block is passed\n  its contents becomes the implicit `block` argument. For\n  example here is a mixin passed a block, and also invoked\n  without passing a block:\n\n      mixin article(title)\n        .article\n          .article-wrapper\n            h1= title\n            if block\n              block\n            else\n              p No content provided\n      \n      +article('Hello world')\n      \n      +article('Hello world')\n        p This is my\n        p Amazing article\n\n   yields:\n   \n       <div class=\"article\">\n         <div class=\"article-wrapper\">\n           <h1>Hello world</h1>\n           <p>No content provided</p>\n         </div>\n       </div>\n\n       <div class=\"article\">\n         <div class=\"article-wrapper\">\n           <h1>Hello world</h1>\n           <p>This is my</p>\n           <p>Amazing article</p>\n         </div>\n       </div>\n\n  Mixins can even take attributes, just like a tag. When\n  attributes are passed they become the implicit `attributes`\n  argument. Individual attributes can be accessed just like\n  normal object properties:\n  \n      mixin centered\n        .centered(class=attributes.class)\n          block\n      \n      +centered.bold Hello world\n      \n      +centered.red\n        p This is my\n        p Amazing article\n  \n   yields:\n   \n       <div class=\"centered bold\">Hello world</div>\n       <div class=\"centered red\">\n         <p>This is my</p>\n         <p>Amazing article</p>\n       </div>\n  \n   If you use `attributes` directly, *all* passed attributes\n   get used:\n   \n      mixin link\n        a.menu(attributes)\n          block\n      \n      +link.highlight(href='#top') Top\n      +link#sec1.plain(href='#section1') Section 1\n      +link#sec2.plain(href='#section2') Section 2\n  \n   yields:\n   \n       <a href=\"#top\" class=\"highlight menu\">Top</a>\n       <a id=\"sec1\" href=\"#section1\" class=\"plain menu\">Section 1</a>\n       <a id=\"sec2\" href=\"#section2\" class=\"plain menu\">Section 2</a>\n   \n   If you pass arguments, they must directly follow the mixin:\n   \n      mixin list(arr)\n        if block\n          .title\n            block\n        ul(attributes)\n          each item in arr\n            li= item\n      \n      +list(['foo', 'bar', 'baz'])(id='myList', class='bold')\n  \n   yields:\n   \n       <ul id=\"myList\" class=\"bold\">\n         <li>foo</li>\n         <li>bar</li>\n         <li>baz</li>\n       </ul>\n"]],"start1":0,"start2":0,"length1":0,"length2":11526}]],"length":11526}
